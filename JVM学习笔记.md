## I.内存区域

Java进程的内存区域分为：方法区、堆、虚拟机栈、本地方法栈、程序计数器。如下图：

![](./resources/JVM内存区域.png)

其中方法区和堆是所有线程共享的区域，虚拟机栈、本地方法栈、程序计数器是线程私有的。

1. 方法区：用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。方法区亦称为元空间（Meta Space）。常量池属于方法区的一部分，用于存放编译期产生的各种字面常量和符号引用。当方法区的空间不能满足新的内存分配需求时，抛出OutOfMemoryError错误。

   字符串常量池属于常量池的一部分，在Java7之后，字符串常量池已挪到堆中。

2. 堆：用于存放对象实例。基于垃圾收集器分代收集的理论，堆通常被划分成如下的区域：

   ![](./resources/堆区域.png)

   新生代中的对象朝生夕灭，老年代中的对象存活时间通常更久。不过，近几年的多款垃圾收集器设计并不遵循分代收集理论（例如G1收集器、Shenandoah收集器、ZGC收集器等），因此对于这些新颖的收集器，以上堆的分区并不适用。

3. 虚拟机栈：生命周期与线程一样，其描述的是Java方法执行的线程内存模型。每个Java方法执行的时候，Java虚拟机都会创建一个栈帧，用于存放局部变量表、操作数栈、动态链接、方法出口等信息。一个方法被调用至执行完毕的过程，就对应了一个栈帧的入栈和出栈。

   虚拟机栈有两种异常。如果线程请求的栈深度大于虚拟机允许的栈深度，抛出StackOverflowError错误。如果虚拟机栈的容量允许动态扩展，当扩展时无法请求到足够的内存时抛出OutOfMemoryError错误。

4. 本地方法栈：本地方法栈的作用与虚拟机栈的作用类似，只不过虚拟机栈服务于Java方法，而本地方法栈服务与native方法。本地方法栈也会抛出StackOverflowError和OutOfMemoryError错误。

5. 程序计数器：程序计数器（PC）保存下一条待执行指令的地址。

6. 直接内存：直接内存不属于Java进程运行时的数据区，该部分内存属于物理内存的一部分，Java中可以使用Native函数库分配直接内存。在进行虚拟机内存规划时应当考虑这部分内存。

## II.内存区域调整参数

| 参数                    | 使用及解释                                             |
| ----------------------- | ------------------------------------------------------ |
| -Xms                    | -Xms10M 堆内存最小值设为10MB                           |
| -Xmx                    | -Xmx10M 堆内存最大值设为10MB                           |
| -Xss                    | -Xss128K 虚拟机栈的容量设为128KB                       |
| -XX:MetaspaceSize       | -XX:MetaspaceSize=10M 元空间容量大小设为10MB           |
| -XX:MaxMetaspaceSize    | -XX:MaxMetaspaceSize=10M 元空间最大容量设置为10MB      |
| -XX:MaxDirectMemorySize | -XX:MaxDirectMemorySize=10M 最大的直接内存容量设为10MB |
|                         |                                                        |

关于虚拟机栈的大小说明：如上述表格中，-Xss128K限制每个线程的栈容量为

128KB。当一个线程执行的方法数量太多导致栈帧数量增多，而每个栈帧占用一定的内存大小，当虚拟机栈不能够再容纳任何栈帧时会抛出StackOverflowError错误。