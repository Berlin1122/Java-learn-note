# Mysql学习笔记

InnoDB引擎层提供redolog,Server层提供binlog

redolog:记录在什么数据页上发生了什么修改

binlog:记录操作语句的原始逻辑

innodb_flush_log_at_trx_commit参数设置为1，事务的redolog提交之后记录会直接刷新到磁盘中

sync_binlog参数设置为1，事务的binlog会直接同步到磁盘中

mysql：WAL技术，先写日志后写磁盘

mysql最小的数据读取单位：页，每个数据页的默认大小16KB

**MVCC：**据库的多版本并发控制。通过在每次对记录更新时记录一条回滚操作，最新值可以通过回滚操作回滚到之前的某个状态。

**mysql语句执行流程：**

![](./resources/mysql执行流程.png)

## 事务

事务：引擎层提供的功能

事务隔离的实现：

事务的四个特性：

1. **原子性**：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态
2. **一致性**：事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。
3. **隔离性**：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
4. **持久性**：当事务正确完成后，它对于数据的改变是永久性的

mysql事务隔离级别：

- 读未提交：读到未提交的事务中的内容。

- 读提交：读的时候能看见的内容绝对是已经提交过的事务。

- 可重复读：事务在整个期间（事务开始和事务提交之间）看到的数据始终是一直的。

- 串行化：每个事务之间是串行方式执行的。

## 索引

InnoDB引擎采用B+树作为索引的存储结构，好处是减少了磁盘IO时间，因为B+树的可以实现使用很少的层就能存储大量的数据，而每遍历树的一个节点都是对磁盘IO操作。在B+树中，只有叶子结点存储真正的数据，其他非叶子结点存储索引的值。

**联合索引**是指在多个字段上建立一个索引，只要符合最左前缀原则都可使联合索引生效，比如联合索引（a,b,c）,查询时用到(a),(a,b),(a,b,c)都是可以使得索引生效的，而(b,c),(b),(c)这种组合不能生效。

**覆盖索引**可以解决回表问题，要做到覆盖索引需要从sql语句和索引层面实现，原理就是在查找非主键索引时就可以获取到需要的字段，这时就不需要再到主键索引树上查询。

读提交和可重复读使用视图来实现事务的隔离，读提交在每个sql语句执行时创建，可重复读在事务开始时创建视图，后面的操作都是基于视图上的数据。

**普通索引和唯一索引的选择**：唯一索引最突出的优点是能够保证字段不会重复，如果有这个需求，并且在业务代码中不保证字段一定是唯一的前提下，使用唯一索引可以实现这个功能。不过，当在业务代码中能保证字段的插入是不会重复的情况下，对于插入之后短时间立即读取内容则使用unique索引效果会好一些，而对于主要是进行更改记录（插入、更改），查询较少的情况下，使用普通的索引效果更好，因为普通索引可以使用changeBuffer,可以将更改操作记录到内存中而不用每次都要从磁盘调出对应的数据页。

## MySQL锁

**全局锁**

**FTWRL**:整库加读锁，对表的增删改和对库的修改都会被阻塞。只有查询的操作可以得到执行。使用场景是对于不支持数据库事务的引擎，如果需要备份数据，可以使用这个命令。不过如果数据库支持事务，比如InnoDB,那么进行数据库备份就不需要对整库加锁，将事务级别设置为**可重复读**，再使用：**mysqldump –single-transaction**，进行备份。

**表级锁(读写锁实现)**

- 表锁：加锁  **lock tables [table-name] read/write**;解锁 **unlock tables**;使用lock tables [table-name] read命令之后，当前线程只允许进行读操作，使用lock tables [table-name] write 命令之后，当前线程可进行读和写操作。需要强调的是，读锁与读锁之间不互斥，读锁和写锁互斥，写锁和写锁互斥。
- MDL：全称 metadata lock,元数据锁，Mysql5.5版本之后引入的。不需要显示使用，当访问一个表的时候自动加上。也是分读锁和写锁，当对表进行数据的增删改查时使用读锁，当对表结构进行更改（比如增加字段，修改字段名称等）时加写锁。MDL在sql语句执行时获取，在事务提交之后才释放。

**行锁（读写锁实现）**

两阶段锁：在InnoDB事务中，行锁是在需要的时候加上的，但并不是不需要了就立刻释放，而是要等到事务提交之后才释放，这就是两阶段锁协议。

行锁即加在行记录上的锁，对行进行修改是加写锁，读取时加写锁。



事务中死锁问题：以行锁为例

![](./resources/行锁-死锁情况.png)

如上图，两个事务互相等待对方占有的行锁，发生了死锁。解决方法如下：

1. 配置innodb_lock_wait_timeout最大等待时间，第一个等待超过这个值的线程主动退出，其他线程获取到锁。比如innodb_lock_wait_timeout=50，当事务A等待超过50秒之后，主动退出。此时事务B得到锁。
2. 开启锁检测：innodb_deadlock_detect=on;当发生了死锁，事务可以自行检测到并通过回滚某个处于死锁中的事务快速解决死锁问题，而当多个线程都在进行死锁检测时会消耗大量CPU。

可重复读的核心是一致性读，事务更新数据时只能使用当前读策略，如果当前记录的行锁被其他事物持有，则需要等待。

更新数据时使用当前读策略，即在最新的及记录上进行修改，保证了多个事务同时修改同一行记录时不丢失更新。在一个事务中，数据的最新值不一定能被当前事务读到，而如果对select语句进行如下增添则会同样达到当前读的效果：select ... from ... where ... lock in share mode,或者 select ... from ... where ... for update，对应的锁操作就是前者加了共享锁，后者加了排他锁。



在读提交和可重复读情况下，事务的一致性快照创建的时间不一样，对于读提交，一致性快照在每个语句执行前创建，而对于可重复读，只要在事务开始时创建一致性视图，则在整个事务期间，一致性视图都是不变的。

一致性读：对应一致性视图上面的普通查询操作

当前读：总是读取已提交的最新版本。

对于可重复读，查询只承认在事务启动之前已经提交完成的数据。

对于读提交：查询只承认在语句启动前就已经提交完成的数据。




